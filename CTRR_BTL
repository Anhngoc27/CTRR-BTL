import tkinter as tk
from tkinter import ttk, messagebox
import matplotlib
import matplotlib.pyplot as plt
import networkx as nx
import heapq
from collections import deque
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

HAS_LIBRARY = True

# ================== Lớp GraphApp ==================
class GraphApp:
    def __init__(self):
        self.num_vertices = 0        # Số đỉnh
        self.edges = []              # Danh sách cạnh
        self.adjacency_list = {}     # Danh sách kề

    # Lưu đồ thị ra file
    def save_files(self):
        if self.num_vertices == 0:
            print("Không có đồ thị để lưu.")
            return
        with open("graph.txt", "w", encoding="utf-8") as f:
            f.write(f"Số đỉnh: {self.num_vertices}\n")
            f.write(f"Số cạnh: {len(self.edges)}\n")
            f.write("Danh sách cạnh:\n")
            for u, v, w in self.edges:
                f.write(f"{u} {v} {w}\n")
        print("Đã lưu đồ thị vào file graph.txt")

    # ================== Prim ==================
    def prim_algorithm(self, start_node=0):
        if self.num_vertices == 0:
            return [], 0
        min_heap = [(0, start_node, -1)]  # (trọng số, đỉnh hiện tại, đỉnh cha)
        visited = [False] * self.num_vertices
        total_weight = 0
        mst_edges = []
    
        while min_heap:
            weight, current_node, parent = heapq.heappop(min_heap)
            if visited[current_node]:
                continue
            visited[current_node] = True
            if parent != -1:
                mst_edges.append((parent, current_node, weight))
                total_weight += weight
            for neighbor, w in self.adjacency_list.get(current_node, []):
                if not visited[neighbor]:
                    heapq.heappush(min_heap, (w, neighbor, current_node))
        return mst_edges, total_weight
        
# ================== Thuật toán ==================

# Tìm đường đi ngắn nhất (Dijkstra)
def dijkstra(graph, start, end):
    q = [(0, start)]           # Hàng đợi ưu tiên: (khoảng cách tạm thời, nút hiện tại)
    dist = {start: 0}          # Lưu khoảng cách ngắn nhất từ start tới từng nút
    prev = {start: None}       # Lưu nút trước đó để tạo đường đi

    while q:
        d, u = heapq.heappop(q)    # Lấy nút có khoảng cách nhỏ nhất ra
        # d: khoảng cách tạm thời từ start đến nút u
        # u: nút hiện tại đang xét

        if u == end:
            break
        for v, w in graph.get(u, []):
        # v: nút láng giềng của u
        # w: trọng số cạnh từ u tới v
            if v not in dist or d + w < dist[v]:
                dist[v] = d + w
                prev[v] = u
                heapq.heappush(q, (d + w, v))

    # Tạo đường đi từ start đến end
    path = []
    node = end
    while node is not None:
        path.append(node)
        node = prev.get(node)
    return path[::-1], dist.get(end, float('inf'))

# Duyệt đồ thị theo BFS & DFS
# BFS – duyệt theo chiều rộng
def bfs(graph_adj, start):
    if start not in graph_adj:
        return []
    visited = set()
    queue = deque([start])
    order = []

    while queue:
        u = queue.popleft()
        if u not in visited:
            visited.add(u)
            order.append(u)
            for v, _ in graph_adj.get(u, []):
                if v not in visited:
                    queue.append(v)
    return order
# DFS – dạng stack (không đệ quy)
def dfs_stack(graph_adj, start):
    if start not in graph_adj:
        return []
    stack = [start]
    visited = set()
    order = []

    while stack:
        u = stack.pop()
        if u not in visited:
            visited.add(u)
            order.append(u)
            # đưa hàng xóm vào stack
            for v, _ in reversed(graph_adj.get(u, [])):
                if v not in visited:
                    stack.append(v)
    return order

# Kiểm tra một đồ thị có phải đồ thị 2 phía không
def is_bipartite(graph_adj):
    """Kiểm tra xem đồ thị có phải là đồ thị 2 phía không bằng thuật toán BFS.
    :param graph_adj: Danh sách kề của đồ thị. graph_adj[i] là list các đỉnh kề với i.
    :return: True nếu là đồ thị 2 phía, False nếu không phải."""
    num_nodes = len(graph_adj)
    color = [0] * num_nodes  # 0: chưa tô, 1: màu 1, -1: màu 2

    # Đồ thị có thể không liên thông, nên cần duyệt qua tất cả các đỉnh.
    for start_node in range(num_nodes):
        if color[start_node] == 0:
            queue = deque([start_node])  # Khởi tạo BFS
            color[start_node] = 1
            while queue:
                u = queue.popleft()
                for v in graph_adj[u]:  # Duyệt qua tất cả các đỉnh kề (v) của đỉnh hiện tại (u)
                    if color[v] == 0:   # Nếu đỉnh kề (v) chưa được tô màu, ta tô màu nó ngược với u
                        color[v] = -color[u]
                        queue.append(v)
                    elif color[v] == color[u]:  #Nếu đỉnh kề (v) đã được tô màu VÀ CÓ CÙNG MÀU với u,thì đồ thị KHÔNG phải là đồ thị 2 phía.
                        return False
    return True

# ================== Chuyển đổi biểu diễn đồ thị ==================
# Ma trận kề -> Danh sách kề
def adjacency_matrix_to_list(adj_matrix, directed=False):
    adjacency_list = {}
    for u in range(len(adj_matrix)):    # Duyệt từng hàng ứng với từng đỉnh
        adjacency_list[u] = []
        for v in range(len(adj_matrix[u])):
            weight = adj_matrix[u][v]
            if weight != 0:
                adjacency_list[u].append((v, weight))
    return adjacency_list
# Danh sách kề -> Danh sách cạnh
def adjacency_list_to_edge_list(adj_list, directed=False):
    edge_list = []
    for u in adj_list:
        for v, weight in adj_list[u]:
            if directed or (u < v):
                edge_list.append((u, v, weight))
    return edge_list
# Danh sách cạnh -> Ma trận kề
def edge_list_to_adjacency_matrix(edge_list, num_nodes, directed=False):
    adj_matrix = [[0 for _ in range(num_nodes)] for _ in range(num_nodes)] # Tạo ma trận NxN chứa toàn 0
    for u, v, weight in edge_list:
        adj_matrix[u][v] = weight
        if not directed:
            adj_matrix[v][u] = weight
    return adj_matrix

# ================== Kruskal ==================
# Cấu trúc Disjoint Set (Union-Find) dùng kiểm tra vòng
class DisjointSet:
    def __init__(self, nodes):
        self.parent = {n: n for n in nodes}

    def find(self, n):
        if self.parent[n] != n:
            self.parent[n] = self.find(self.parent[n])  # path compression
        return self.parent[n]

    def union(self, a, b):
        root_a, root_b = self.find(a), self.find(b)
        if root_a != root_b:
            self.parent[root_b] = root_a
            return True
        return False
# Thuật toán Kruskal
def kruskal(nodes, edges):
    #nodes: danh sách các nút ['A','B',...]
    #edges: danh sách cạnh [(trọng_số, u, v), ...]
    edges.sort()
    ds = DisjointSet(nodes)
    mst = []
    total_weight = 0
    for w, u, v in edges:
        if ds.union(u, v):
            mst.append((u, v, w))
            total_weight += w
    return mst, total_weight

# ==================  Ford-Fulkerson ==================
def bfs_ff(residual, source, sink, parent):
    visited = set()
    queue = deque([source])
    visited.add(source)
    while queue:
        u = queue.popleft()
        for v in residual[u]:
            # còn dung lượng và chưa thăm
            if residual[u][v] > 0 and v not in visited:
                queue.append(v)
                visited.add(v)
                parent[v] = u
                if v == sink:
                    return True
    return False
def ford_fulkerson(graph, source, sink):
    # tạo bản sao residual graph
    residual = {u: dict(vs) for u, vs in graph.items()}
    parent = {}
    max_flow = 0
    # lặp đến khi không còn đường tăng
    while bfs_ff(residual, source, sink, parent):
        # tìm dung lượng nhỏ nhất trên đường tăng
        path_flow = float('inf')
        v = sink

        while v != source:
            u = parent[v]
            path_flow = min(path_flow, residual[u][v])
            v = u

        # tăng tổng flow
        max_flow += path_flow

        # cập nhật residual
        v = sink
        while v != source:
            u = parent[v]
            residual[u][v] -= path_flow   # giảm chiều thuận
            residual[v].setdefault(u, 0)
            residual[v][u] += path_flow   # tăng chiều ngược
            v = u
    return max_flow

# ==================  Fleury ==================
# Kiểm tra số cạnh có thể đi bằng DFS (để phát hiện cầu)
def dfs_count(graph, u, visited):
    visited.add(u)
    cnt = 1
    for v in graph[u]:
        if v not in visited:
            cnt += dfs_count(graph, v, visited)
    return cnt
# Kiểm tra cạnh (u, v) có phải cầu hay không
def is_bridge(graph, u, v):
    # số đỉnh reachable khi chưa xóa cạnh
    visited = set()
    cnt1 = dfs_count(graph, u, visited)
 
    # tạm thời xóa cạnh
    graph[u].remove(v)
    graph[v].remove(u)
 
    visited = set()
    cnt2 = dfs_count(graph, u, visited)
 
    # thêm lại cạnh
    graph[u].append(v)
    graph[v].append(u)
 
    # nếu số reachable giảm → đó là cầu
    return cnt2 < cnt1
# Thuật toán Fleury
def fleury(graph, start):
    graph = {u: list(vs) for u, vs in graph.items()}  # copy
    path = [start]
    u = start
 
    while any(graph.values()):
        for v in graph[u]:
            # nếu chỉ còn đúng 1 cạnh, phải đi nó
            if len(graph[u]) == 1 or not is_bridge(graph, u, v):
                graph[u].remove(v)
                graph[v].remove(u)
                path.append(v)
                u = v
                break
    return path

# ================== Hierholzer ==================
def hierholzer(graph, start):
    """
    Thuật toán tìm chu trình Euler
    graph: danh sách kề dạng {u: [v1, v2,...]}
    start: đỉnh bắt đầu
    """
    stack = [start]  # stack tạm thời
    euler_path = []  # lưu kết quả
    adj = {u: list(vs) for u, vs in graph.items()}  # copy graph

    while stack:
        u = stack[-1]
        if adj[u]:
            v = adj[u].pop(0)
            stack.append(v)
        else:
            euler_path.append(stack.pop())
    return euler_path[::-1]  # đảo ngược kết quả

# ================== GIAO DIỆN TKINTER ==================
class GraphGUI:
    def __init__(self, root, app: GraphApp):
        self.root = root
        self.app = app
        self.root.title("Ứng dụng trực quan hóa và xử lý đồ thị")
        self.pos = None  # giữ vị trí layout để không nhảy khi redraw

        # ======= FRAME TRÁI: CHỨC NĂNG =======
        frame_left = tk.Frame(root, padx=10, pady=10)
        frame_left.pack(side=tk.LEFT, fill=tk.Y)

        tk.Label(frame_left, text="CHỨC NĂNG", font=("Arial", 14, "bold")).pack(pady=10)

        # === Nút chức năng phần cơ bản ===
        funcs_basic = [
            ("Vẽ đồ thị trực quan", self.draw_graph_canvas_cmd),
            ("Lưu đồ thị", self.save_graph),
            ("Tìm đường đi ngắn nhất (Dijkstra)", self.dijkstra_ui),
            ("Duyệt đồ thị BFS & DFS", self.bfsdfs_ui),
            ("Kiểm tra đồ thị 2 phía", self.check_bipartite),
            ("Chuyển đổi biểu diễn đồ thị", self.convert_ui),
        ]

        tk.Label(frame_left, text="PHẦN CƠ BẢN", font=("Arial", 12, "bold")).pack(pady=5)
        for text, func in funcs_basic:
            ttk.Button(frame_left, text=text, width=35, command=func).pack(pady=3)

        # === Nút chức năng phần nâng cao ===
        tk.Label(frame_left, text="PHẦN NÂNG CAO", font=("Arial", 12, "bold")).pack(pady=10)

        funcs_advanced = [
            ("Prim ", self.run_prim),
            ("Kruskal ", self.run_kruskal),
            ("Ford-Fulkerson", self.run_ff),
            ("Fleury  ", self.run_fleury),
            ("Hierholzer ", self.run_hierholzer),
        ]

        for text, func in funcs_advanced:
            ttk.Button(frame_left, text=text, width=35, command=func).pack(pady=3)

        # ======= FRAME PHẢI: NHẬP DỮ LIỆU =======
        frame_right = tk.Frame(root, padx=10, pady=10)
        frame_right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

        tk.Label(frame_right, text="NHẬP DỮ LIỆU ĐỒ THỊ", font=("Arial", 14, "bold")).pack()

        tk.Label(frame_right, text="Số đỉnh:").pack()
        self.entry_vertices = tk.Entry(frame_right, width=10)
        self.entry_vertices.pack()

        tk.Label(frame_right, text="Danh sách cạnh (u v w), mỗi dòng 1 cạnh:").pack()
        self.text_edges = tk.Text(frame_right, width=40, height=12)
        self.text_edges.pack()

        ttk.Button(frame_right, text="Tải dữ liệu đồ thị", command=self.load_graph).pack(pady=6)

        # Thêm một số nút hỗ trợ nhỏ
        btn_frame = tk.Frame(frame_right)
        btn_frame.pack(pady=4)
        ttk.Button(btn_frame, text="Xóa dữ liệu", command=self.clear_graph).pack(side=tk.LEFT, padx=4)
        ttk.Button(btn_frame, text="Mẫu ví dụ", command=self.load_example).pack(side=tk.LEFT, padx=4)

        # ======= KHUNG VẼ ĐỒ THỊ =======
        frame_graph = tk.Frame(root)
        frame_graph.pack(side=tk.BOTTOM, fill=tk.BOTH, expand=True)

        self.fig, self.ax = plt.subplots(figsize=(6, 5))
        self.canvas = FigureCanvasTkAgg(self.fig, master=frame_graph)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    # ========================= HÀM NHẬP / XỬ LÝ =========================
    def load_example(self):
        # ví dụ nhỏ để test
        sample = [
            "0 1 4",
            "0 2 3",
            "1 2 1",
            "1 3 2",
            "2 3 4",
            "3 4 2",
            "2 4 5"
        ]
        self.entry_vertices.delete(0, tk.END)
        self.entry_vertices.insert(0, "5")
        self.text_edges.delete("1.0", tk.END)
        self.text_edges.insert("1.0", "\n".join(sample))
        self.load_graph()

    def clear_graph(self):
        self.entry_vertices.delete(0, tk.END)
        self.text_edges.delete("1.0", tk.END)
        self.app.num_vertices = 0
        self.app.edges = []
        self.app.adjacency_list = {}
        self.pos = None
        self.ax.clear()
        self.canvas.draw()

    def load_graph(self):
        try:
            n = int(self.entry_vertices.get())
            if n <= 0:
                raise ValueError
            self.app.num_vertices = n
        except:
            messagebox.showerror("Lỗi", "Số đỉnh không hợp lệ!")
            return
        
        self.app.edges = []
        self.app.adjacency_list = {i: [] for i in range(self.app.num_vertices)}

        lines = [ln.strip() for ln in self.text_edges.get("1.0", tk.END).strip().splitlines() if ln.strip()]
        for line in lines:
            try:
                u, v, w = map(int, line.split())
            except:
                messagebox.showerror("Lỗi", f"Cạnh không hợp lệ: {line}")
                return
            if not (0 <= u < self.app.num_vertices and 0 <= v < self.app.num_vertices):
                messagebox.showerror("Lỗi", f"Đỉnh ngoài phạm vi: {line}")
                return
            self.app.edges.append((u, v, w))
            self.app.adjacency_list[u].append((v, w))
            self.app.adjacency_list[v].append((u, w))
        
        # reset layout để giữ vị trí nhất quán
        self.pos = None
        self.draw_graph_canvas()  # vẽ ban đầu
        messagebox.showinfo("Thành công", "Đã tải dữ liệu đồ thị!")

    # ========================= VẼ VÀ MINH HỌA =========================
    def _ensure_graph(self):
        # Tạo graph NetworkX từ app.edges
        G = nx.Graph()
        for u, v, w in self.app.edges:
            G.add_edge(u, v, weight=w)
        return G

    def draw_graph_canvas(self, highlight_edges=None, highlight_nodes=None, edge_labels=True):
        """
        Vẽ đồ thị vào canvas, highlight_edges = list of (u,v) hoặc set, highlight_nodes = list/set
        Giữ self.pos để nodes không nhảy khi cập nhật.
        """
        G = self._ensure_graph()
        if len(G.nodes) == 0:
            self.ax.clear()
            self.canvas.draw()
            return

        if self.pos is None:
            # Tạo layout một lần (dùng seed để cố định)
            self.pos = nx.spring_layout(G, seed=42)

        self.ax.clear()

        # Node colors
        node_colors = []
        highlight_nodes = set(highlight_nodes) if highlight_nodes else set()
        for n in G.nodes():
            if n in highlight_nodes:
                node_colors.append("yellow")
            else:
                node_colors.append("lightblue")

        nx.draw_networkx_nodes(G, self.pos, node_color=node_colors, ax=self.ax, node_size=700)
        nx.draw_networkx_labels(G, self.pos, ax=self.ax)

        # Edge colors: highlight_edges đỏ, khác đen
        highlight_edges_set = set()
        if highlight_edges:
            for a,b in highlight_edges:
                highlight_edges_set.add((a,b))
                highlight_edges_set.add((b,a))

        edge_colors = []
        widths = []
        for (u, v) in G.edges():
            if (u, v) in highlight_edges_set:
                edge_colors.append("red")
                widths.append(3.0)
            else:
                edge_colors.append("black")
                widths.append(1.5)

        nx.draw_networkx_edges(G, self.pos, ax=self.ax, edge_color=edge_colors, width=widths)
        if edge_labels:
            labels = nx.get_edge_attributes(G, 'weight')
            nx.draw_networkx_edge_labels(G, self.pos, edge_labels=labels, ax=self.ax)

        self.canvas.draw()

    # wrapper để gọi từ menu
    def draw_graph_canvas_cmd(self):
        self.draw_graph_canvas()

    # ========================= CHỨC NĂNG MENU =========================
    def save_graph(self):
        self.app.save_files()
        messagebox.showinfo("Lưu file", "Đã lưu vào graph.txt")

    def dijkstra_ui(self):
        if self.app.num_vertices == 0:
            messagebox.showerror("Lỗi", "Chưa có đồ thị!")
            return
        win = tk.Toplevel(self.root)
        win.title("Dijkstra")

        tk.Label(win, text="Đỉnh bắt đầu:").pack()
        s = tk.Entry(win); s.pack()
        tk.Label(win, text="Đỉnh kết thúc:").pack()
        e = tk.Entry(win); e.pack()

        def run():
            try:
                start = int(s.get()); end = int(e.get())
            except:
                messagebox.showerror("Lỗi", "Đỉnh không hợp lệ!")
                return
            path, dist = dijkstra(self.app.adjacency_list, start, end)
            if path == [end] and dist == float('inf'):
                messagebox.showinfo("Kết quả", "Không tồn tại đường đi.")
                return

            # Minh họa từng bước: tô dần các đỉnh trên đường đi
            edges_on_path = [(path[i], path[i+1]) for i in range(len(path)-1)]
            # animate: tô node/edge dần dần
            steps = []
            for i in range(len(path)):
                nodes = path[:i+1]
                edges = [(path[j], path[j+1]) for j in range(i) if i>0]
                steps.append((edges, nodes))

            idx = 0
            def animate():
                nonlocal idx
                if idx >= len(steps):
                    messagebox.showinfo("Dijkstra", f"Đường đi: {path}\nKhoảng cách: {dist}")
                    return
                eds, nds = steps[idx]
                self.draw_graph_canvas(highlight_edges=eds, highlight_nodes=nds)
                idx += 1
                self.root.after(500, animate)
            animate()

        ttk.Button(win, text="Chạy", command=run).pack(pady=5)

    def bfsdfs_ui(self):
        if self.app.num_vertices == 0:
            messagebox.showerror("Lỗi", "Chưa có đồ thị!")
            return
        # show small window chọn BFS hay DFS
        win = tk.Toplevel(self.root)
        win.title("BFS & DFS")

        tk.Label(win, text="Chọn đỉnh bắt đầu:").pack()
        s = tk.Entry(win); s.pack()
        tk.Label(win, text="Chọn phương pháp:").pack()
        method = tk.StringVar(value="BFS")
        ttk.Radiobutton(win, text="BFS", variable=method, value="BFS").pack()
        ttk.Radiobutton(win, text="DFS", variable=method, value="DFS").pack()

        def run():
            try:
                start = int(s.get())
            except:
                messagebox.showerror("Lỗi", "Đỉnh không hợp lệ!")
                return
            if method.get() == "BFS":
                order = bfs(self.app.adjacency_list, start)
            else:
                order = dfs_stack(self.app.adjacency_list, start)

            # animate visiting nodes in order
            idx = 0
            def animate():
                nonlocal idx
                if idx >= len(order):
                    messagebox.showinfo(method.get(), f"Thứ tự thăm: {order}")
                    return
                visited = order[:idx+1]
                self.draw_graph_canvas(highlight_nodes=visited)
                idx += 1
                self.root.after(400, animate)
            animate()

        ttk.Button(win, text="Chạy", command=run).pack(pady=6)

    def check_bipartite(self):
        if self.app.num_vertices == 0:
            messagebox.showerror("Lỗi", "Chưa có đồ thị!")
            return
        Gsimple = {u:[v for v,_ in nbrs] for u,nbrs in self.app.adjacency_list.items()}
        bip = is_bipartite(Gsimple)
        messagebox.showinfo("Đồ thị 2 phía", f"Đồ thị 2 phía? {bip}")

    def convert_ui(self):
        # hiển thị 3 biểu diễn
        if self.app.num_vertices == 0:
            messagebox.showerror("Lỗi", "Chưa có đồ thị!")
            return
        adj_matrix = [[0]*self.app.num_vertices for _ in range(self.app.num_vertices)]
        for u,v,w in self.app.edges:
            adj_matrix[u][v] = w
            adj_matrix[v][u] = w
        adj_list = adjacency_matrix_to_list(adj_matrix)
        edge_list = adjacency_list_to_edge_list(self.app.adjacency_list)
        s = "Ma trận kề:\n"
        for row in adj_matrix:
            s += str(row) + "\n"
        s += "\nDanh sách kề:\n" + str(adj_list)
        s += "\n\nDanh sách cạnh:\n" + str(edge_list)
        messagebox.showinfo("Chuyển đổi biểu diễn", s)

    # ========================= TRỰC QUAN HÓA THUẬT TOÁN =========================
    def run_prim(self):
        if self.app.num_vertices == 0:
            messagebox.showerror("Lỗi", "Chưa có đồ thị!")
            return
        # Chạy Prim sử dụng danh sách kề
        n = self.app.num_vertices
        visited = [False]*n
        start = 0
        pq = [(0, start, -1)]
        mst_edges = []
        total = 0

        def step():
            nonlocal total
            while pq and visited[pq[0][1]]:
                heapq.heappop(pq)
            if not pq:
                messagebox.showinfo("Prim", f"Hoàn thành!\nCạnh MST: {mst_edges}\nTổng: {total}")
                return
            w,u,parent = heapq.heappop(pq)
            if visited[u]:
                self.root.after(200, step)
                return
            visited[u] = True
            if parent != -1:
                mst_edges.append((parent, u))
                total += w
            # thêm đỉnh kề
            for v,wt in self.app.adjacency_list.get(u, []):
                if not visited[v]:
                    heapq.heappush(pq, (wt, v, u))

            # vẽ highlight các đỉnh đã visited và cạnh đã thuộc MST
            self.draw_graph_canvas(highlight_nodes=[i for i,x in enumerate(visited) if x], highlight_edges=mst_edges)
            self.root.after(600, step)
        step()

    def run_kruskal(self):
        if self.app.num_vertices == 0:
            messagebox.showerror("Lỗi", "Chưa có đồ thị!")
            return
        nodes = list(range(self.app.num_vertices))
        # edges as (w,u,v)
        edges = sorted([(w,u,v) for u,v,w in self.app.edges])
        ds = DisjointSet(nodes)
        mst = []
        idx = 0

        def step():
            nonlocal idx
            if idx >= len(edges) or len(mst) == self.app.num_vertices-1:
                messagebox.showinfo("Kruskal", f"Hoàn thành!\nCạnh MST: {mst}")
                return
            w,u,v = edges[idx]
            idx += 1
            if ds.union(u,v):
                mst.append((u,v))
            # highlight các cạnh đã chọn
            self.draw_graph_canvas(highlight_edges=mst, highlight_nodes=None)
            self.root.after(600, step)
        step()

    def run_ff(self):
        if self.app.num_vertices == 0:
            messagebox.showerror("Lỗi", "Chưa có đồ thị!")
            return
        win = tk.Toplevel(self.root)
        win.title("Ford-Fulkerson")

        tk.Label(win, text="Nguồn:").pack()
        s = tk.Entry(win); s.pack()
        tk.Label(win, text="Đích:").pack()
        t = tk.Entry(win); t.pack()

        def run():
            try:
                source = int(s.get()); sink = int(t.get())
            except:
                messagebox.showerror("Lỗi", "Đỉnh không hợp lệ!")
                return
            graph_ff = {u: {v:w for v,w in nbrs} for u,nbrs in self.app.adjacency_list.items()}
            maxflow = ford_fulkerson(graph_ff, source, sink)
            messagebox.showinfo("Ford-Fulkerson", f"Lưu lượng tối đa = {maxflow}")
        ttk.Button(win, text="Chạy", command=run).pack(pady=5)

    def run_fleury(self):
        if self.app.num_vertices == 0:
            messagebox.showerror("Lỗi", "Chưa có đồ thị!")
            return
        Gsimple = {u:[v for v,_ in nbrs] for u,nbrs in self.app.adjacency_list.items()}
        odd = [v for v in Gsimple if len(Gsimple[v])%2==1]
        if len(odd) not in [0,2]:
            messagebox.showerror("Lỗi", "Không có chu trình/đường đi Euler.")
            return
        start = odd[0] if odd else 0
        path = fleury(Gsimple, start)
        # animate edges along path
        edges_seq = [(path[i], path[i+1]) for i in range(len(path)-1)]
        idx = 0
        def animate():
            nonlocal idx
            if idx > len(edges_seq):
                messagebox.showinfo("Fleury", f"Đường/chu trình Euler: {path}")
                return
            cur_edges = edges_seq[:idx]
            cur_nodes = path[:idx+1]
            self.draw_graph_canvas(highlight_edges=cur_edges, highlight_nodes=cur_nodes)
            idx += 1
            self.root.after(400, animate)
        animate()

    def run_hierholzer(self):
        if self.app.num_vertices == 0:
            messagebox.showerror("Lỗi", "Chưa có đồ thị!")
            return
        Gsimple = {u:[v for v,_ in nbrs] for u,nbrs in self.app.adjacency_list.items()}
        # chọn đỉnh bắt đầu từ 0 hoặc từ đỉnh khác
        odd = [v for v in Gsimple if len(Gsimple[v])%2==1]
        start = odd[0] if odd else 0
        path = hierholzer(Gsimple, start)
        edges_seq = [(path[i], path[i+1]) for i in range(len(path)-1)]
        idx = 0
        def animate():
            nonlocal idx
            if idx > len(edges_seq):
                messagebox.showinfo("Hierholzer", f"Chu trình Euler: {path}")
                return
            cur_edges = edges_seq[:idx]
            cur_nodes = path[:idx+1]
            self.draw_graph_canvas(highlight_edges=cur_edges, highlight_nodes=cur_nodes)
            idx += 1
            self.root.after(400, animate)
        animate()

# ================== CHẠY GIAO DIỆN ==================
if __name__ == "__main__":
    app = GraphApp()   # TẠO ĐỐI TƯỢNG ứng dụng
    root = tk.Tk()
    gui = GraphGUI(root, app)
    root.mainloop()
